/**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */
options
{
  static = false; // Nao criara metodos estaticos
  DEBUG_LOOKAHEAD = true;
}

 PARSER_BEGIN(Fun)

package parser;
import java.io.FileNotFoundException;
import java.io.FileInputStream;
import recovery.*; // classes de recuperacao
import syntaticTree.*;
import semananalysis.*;
import symtable.*;

public class Fun
{
final static String Version = "Fun Compiler - Semantic - Version 1.0 - 2018";
int contParseError = 0; 	// contador de erros sintaticos
boolean debug_recovery;		// controla verbose de recuperacao de erros
Token lastError = null;

// Define método "main" da classe Fun
	public static void main(String args[]) throws ParseException
	{
	boolean debug_as = false;
	boolean debug_recovery = false;
	boolean print_tree = false;
	
		String filename = "";
		Fun parser;
		int i;
		boolean ms = false;

		System.out.println("Version");
		// lê os parâmetros passados para o compilador
		for (i = 0; i < args.length -1; i++)
		{
		  if(args[i].equals("-debug_AS"))
		  		debug_as = true;
		  else
		  if(args[i].equals("-debug_recovery"))
		  		debug_recovery = true;
		  else
		  if(args[i].equals("-print_tree"))
		  		print_tree = true;
		  else
		  	{
		  	  	System.out.println("Utilizacao : " +
		  	  						"java fun [-debug_AS] [-debug_recovery] [-print_tree] inputfile");
		  	  	System.exit(0);
		 	}
		}

		if (args[i].equals("-"))
		{ // lê da entrada padrão
			System.out.println("Lendo da entrada padrão ...");
			parser = new Fun(System.in); // cria AS
		}
		else
		{ // lê do arquivo
			filename = args[args.length-1];
			System.out.println("Lendo do arquivo " + filename + " ...");
			try {
				parser = new Fun(new FileInputStream(filename));
			}
		  catch (FileNotFoundException e) {
		    		System.out.println("Arquivo " + filename + " nao encontrado.");
		    		return;
		 			}
		}

		ListNode root = null;
		parser.debug_recovery = debug_recovery;
		if (!debug_as) parser.disable_tracing(); // desabilita verbose do AS
		try {
		  		root = parser.program(); // chama o método para fazer análise
		}
		catch (ParseEOFException e)  	
		{
		System.err.println(e.getMessage());
		//parser.contParseError = 1; // não existe recuperação de erros
		}
		finally {
		  System.out.println(parser.token_source.foundLexError() +
		  						"Lexical Errors found");
		  System.out.println(parser.contParseError +
		  						"Syntatic Errors found");
		  	}
		
		// verifica se pode imprimir a arvore sintatica
		if(parser.token_source.foundLexError()
			+ parser.contParseError == 0 && print_tree)
		{
		  PrintTree prt = new PrintTree();
		  prt.printRoot(root);	// chama método para imprimir arvore
		}
		ClassCheck tc = new ClassCheck();
		try {
		  	tc.ClassCheckRoot(root);
		  	System.out.println("0 Semantic error found");
		 }
		 catch (SemanticException e)
		 {
		   System.out.println(e.getMessage());
		 }
	} //main

static public String im(int x)
{
int k;
String s;
   s = tokenImage[x];
   k = s.lastIndexOf("\"");
   try {s = s.substring(1,k);}
   catch (StringIndexOutOfBoundsException e)
   {}
   return s;
}


boolean eof;	// variavel q indica se EOF foi alcancado
// metodo abaixo consome tokens ate alcancar um que pertenca
// ao conjunto de sincronizacao

void consumeUntil(RecoverySet g,
                 ParseException e,
                 String met) throws ParseEOFException,
                                    ParseException
{
  Token tok;

  	if(debug_recovery) // informacao sobre a recuperacao
  	{
  	  	System.out.println();
  	  	System.out.println("*** " + met + " ***");
  		System.out.println("	Synchronizing Set: " + g);
 	}

 	if(g==null) throw e; // se o conjunto e null, propaga a excecao

 	tok = getToken(1); // pega token corrente
 	while(!eof)		   // se nao chegou ao fim do arquivo
 	{
		if(g.contains(tok.kind)) //achou um token do conjunto
		{
		  if(debug_recovery)
		  	System.out.println("Found syncroninzing token: " +
		  						im(tok.kind));
		 break;
		}
		if(debug_recovery)
			System.out.println("Ignoring token: " + im(tok.kind));
		getNextToken();
		tok = getToken(1);
		if(tok.kind == EOF && !g.contains(EOF) ) // fim da entrada
			eof = true;
	}
	if(tok != lastError)
	{ 
		System.out.println(e.getMessage());
		lastError = tok;
		contParseError++;	// incrementa número de erros
	}
	if(eof) throw new ParseEOFException("EOF found prematurely.");
}

} //Fun
PARSER_END(Fun)

TOKEN_MGR_DECLS :
{
	int countLexError = 0;

	public int foundLexError()
	{
   		return countLexError;
	}
}

/* Espa�o a serem desprezados */

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}

SKIP :
{
  "/*" : multilinecomment
}

SKIP :
{
  "//" : singlelinecomment
}

<multilinecomment> SKIP:
{
   "*/" : DEFAULT
|  <~[]>
}

<singlelinecomment> SKIP:
{
   <["\n","\r"]> : DEFAULT
|   <~[]>
}

/* Palavras Reservadas da Linguagem */
TOKEN :
{
  < BREAK: "break" >
| < CLASS: "class" >
| < CONSTRUCTOR: "constructor" >
| < ELSE: "else" >
| < EXTENDS: "extends" >
| < FOR: "for" >
| < IF: "if" >
| < NEW: "new" >
| < PRINT: "print" >
| < READ: "read" >
| < RETURN: "return" >
| < SUPER: "super" >

}


/* Tipos de variáveis */
TOKEN:
{
  < PRIMITIVE_TYPE: (<INT> | <CHAR> | <BOOLEAN> | <FLOAT> | <STRING>) >
| < #INT:"int" >
| < #STRING:"string" >
| < #CHAR:"char" >
| < #FLOAT:"float" >
| < #BOOLEAN:"boolean" >
}

/* Operadores */

TOKEN :
{
  < ASSIGN: "=" >
| < GT: ">" >
| < LT: "<" >
| < EQ: "==" >
| < LE: "<=" >
| < GE: ">=" >
| < NEQ: "!=" >
| < PLUS: "+" >
| < MINUS: "-" >
| < MULTIPLY: "*" >
| < DIVIDE: "/" >
| < REM: "%" >
}

/* Operadores Booleanos */

TOKEN:
{
  < NOT:"NOT" >
| < XOR:"XOR" >
| < AND:"AND" >
| < OR:"OR" >
}

/* Símbolos especiais */
TOKEN :
{
  < LPAREN: "(" >
| < RPAREN: ")" >
| < LBRACE: "{" >
| < RBRACE: "}" >
| < LBRACKET: "[" >
| < RBRACKET: "]" >
| < SEMICOLON: ";" >
| < COMMA: "," >
| < SINGLEQUOTATIONMARKS: "'" >
| < DOT: "." >
| < COLON: ":" >
}

/* Constantes da Linguagem */
TOKEN:
{
  	< number_constant:(
		<int_literal> |
		<float_literal>
	) >
| < #int_literal: (["0"-"9"] (["0"-"9"])*) > // apenas numeros
| < #float_literal: ( ["0"-"9"] (["0"-"9"])* "." ["0"-"9"] (["0"-"9"])* ) > //numeros float com .
| < string_constant: //"constante string como "abcd"
  		"\""( ~["\"","\n","\r"])* "\"" >

| < null_constant : "null" > // constant null
| < char_const: "\""( ~["\n","\r","\f","\t"])* "\"" >
| < #EXPONENT: ["e","E"] (["+","-"])?  (["0"-"9"])+ >
| < boolean_constant:("true"|"false") >
}

/* Identificadores */
TOKEN :
{
  < IDENT: <LETTER> (<LETTER> | <DIGIT> | "_")* >
| < #LETTER:["A"-"Z","a"-"z"] >
| < #DIGIT:["0"-"9"] >
| < #UNDERSCORE:"_" >
}

/* Trata os erros léxicos */

SPECIAL_TOKEN :
{
<INVALID_LEXICAL:
(~ ["a"-"z", "A"-"Z",
  "0"-"9",
  "\"",
  "(",
  ")",
  "[",
  "]",
  "{",
  "}",
  ";",
  ",",
  ".",
  "'",
  "=",
  ">",
  "<",
  "!",
  "+",
  "-",
  "*",
  "/",
  "%",
  " ",
  "\t",
  "\n",
  "\r",
  "\f"
])+>
   {
    System.err.println("Line " + input_stream.getEndLine() +
                           " - Invalid string found: " + image);
    countLexError++;
   }
|
   <INVALID_CONST:
   "\"" (~ ["\n","\r","\""])* ["\n","\r"]>
   {
    System.err.println("Line " + input_stream.getEndLine() +
                           " - String constant has a \\n: " + image);
    countLexError++;
   }
}


ListNode program() throws ParseEOFException :
{
RecoverySet g = First.program;

ListNode l = null, d = null;
}
{
  	<EOF> { return null; }
|
(	l = classlist(g)
	try { 
    	<EOF> { return l; }
	}
	catch (ParseException e)
	{
  		consumeUntil(g, e, "program");
	}
	[ d = program() ]
) { return l; }
}


ListNode classlist(RecoverySet g) throws ParseEOFException :
{
ClassDeclNode c = null;
ListNode l = null;

RecoverySet f = First.classlist.union(g);
}
{
(  c =  classdecl(f) [ l = classlist(g) ]
) {return new ListNode(c, l);}
}


ClassDeclNode classdecl(RecoverySet g) throws ParseEOFException :
{
Token t1 = null, t2 = null, t3 = null;
ClassBodyNode c1 = null;
}
{
try { 
   t1 = <CLASS>  t2 = <IDENT> [ <EXTENDS> t3 = <IDENT> ] c1 = classbody(g)
   {return new ClassDeclNode(t1, t2, t3, c1); }
}
catch(ParseException e)
{
	consumeUntil(g, e, "classdecl");
	return new ClassDeclNode(t1, t2, t3, c1);
}
}


ClassBodyNode classbody(RecoverySet g) throws ParseEOFException :
{
ListNode c = null,
		 v = null,
		 ct = null,
		 m = null;
VarDeclNode vd;
ConstructDeclNode cd;
MethodDeclNode md;
Token t = null;

	RecoverySet f2 = new RecoverySet(SEMICOLON).union(g),
	            f3 = First.methoddecl.union(g).remove(IDENT),
	            f4 = First.constructdecl.union(f3).remove(IDENT),
	            f5 = First.vardecl.union(f4).remove(IDENT);
}
{
	try {
		t = <LBRACE>
			[c = classlist(f5)]
			(LOOKAHEAD(3) vd = vardecl(f2) <SEMICOLON>
				{if (v == null)
					v = new ListNode(vd);
				 else
				 	v.add(vd);
				}
			)*
			(cd = constructdecl(f4)
				{if (ct == null)
					ct = new ListNode(cd);
				 else
				 	ct.add(cd);
				}
			)*
			(md = methoddecl(f3)
				{if (m == null)
					m = new ListNode(md);
				 else
				 	m.add(md);
				}
			)*
		<RBRACE>
		{ return new ClassBodyNode(t, c, v, ct, m); }
	} catch(ParseException e) {
		consumeUntil(g, e, "classbody");
		return new ClassBodyNode(t, c, v, ct, m);
	}
}


//VarDeclNode vardecl(RecoverySet g) throws ParseEOFException :
//{
//Token t1 = null, t2 = null;
//VarInitNode vi = null;
//ListNode l = null;
//int k = 0;
//}
//{
//try { 
//  (t1 = <PRIMITIVE_TYPE> | t1 = <IDENT>)
//  t2 = <IDENT> (<LBRACKET><RBRACKET> { k++; })* vi = varinit(g)
//  {
//
//     l = new ListNode(new VarNode(t2,k)); }
//  (<COMMA> { k = 0; } t2 = <IDENT> (<LBRACKET><RBRACKET> {k++;})
//  	{ l.add(new VarNode(t2, k)); }
//  )*
//  { return new VarDeclNode(t1, l); }
//}
//catch (ParseException e)
//{
//  consumeUntil(g, e, "vardecl");
//  return new VarDeclNode(t1, l)
//}
//}
VarDeclNode vardecl(RecoverySet g) throws ParseEOFException :
{
Token t = null, t1 = null;
VarInitNode vi = null;
ListNode l = null;
int k = 0;
}
{
	try
	{
	  (t = < PRIMITIVE_TYPE > | t = < IDENT >)
	  (<LBRACKET> <RBRACKET> { k++; })* vi = varinit(g)
	  {
	    vi.dim  = k;
	    if(t1 != null)
	    {
	      t = t1;
	  	}
	  	l = new ListNode(vi);
	  }
	  (	    < COMMA > vi = varinit(g)
	    {  l.add(vi); }
	  )*    	  { return new VarDeclNode(t, l); }
	}catch(ParseException e)
	{
	  consumeUntil(g, e, "vardecl");
	 return new VarDeclNode(t, l);
	}
}  

VarInitNode varinit(RecoverySet g) throws ParseEOFException :
{
ExpreNode e1, e2 = null;
}
{
	e1 = lvalue(g) [<ASSIGN> (e2 = alocexpression(g) | e2 = expression(g))]
	{ return new VarInitNode(e1, e2); }
}


ConstructDeclNode constructdecl(RecoverySet g) throws ParseEOFException :
{
Token t = null;
MethodBodyNode m = null;
}
{
	try {
		t = <CONSTRUCTOR> m = methodbody(g)
		{ return new ConstructDeclNode(t, m); }
	} catch(ParseException e) {
		consumeUntil(g, e, "constructdecl");
		return new ConstructDeclNode(t, m);
	}
}


MethodDeclNode methoddecl(RecoverySet g) throws ParseEOFException :
{
Token t1 = null,
	  t2 = null;
int k = 0;
MethodBodyNode m = null;
}
{
	try {
		(t1 = <PRIMITIVE_TYPE> | t1 = <IDENT>)
		(<LBRACKET> <RBRACKET> { k++; })*
		t2 = <IDENT> m = methodbody(g)
		{ return new MethodDeclNode(t1, k, t2, m); }
	} catch(ParseException e) {
		consumeUntil(g, e, "methoddecl");
		return new MethodDeclNode(t1, k, t2, m); 
	}
}


MethodBodyNode methodbody(RecoverySet g) throws ParseEOFException :
{
Token t1 = null;
ListNode l = null;
StatementNode s = null;

RecoverySet f = new RecoverySet(RPAREN).union(g);
}
{
	try {
		t1 = <LPAREN> l = paramlist(f) <RPAREN> s = statement(g)
		{ return new MethodBodyNode(t1, l, s); }
		  
	} catch(ParseException e) {
		consumeUntil(g, e, "methodbody");
		return new MethodBodyNode(t1, l, s);
	}
}

ListNode paramlist(RecoverySet g) throws ParseEOFException :
{
ListNode p = null,
		 q = null;
Token t1 = null,
	  t2 = null;
int k = 0;
}
{
	try {
	   [
	    (t1 = <PRIMITIVE_TYPE> | t1 = <IDENT>) t2 = <IDENT>
	    (<LBRACKET> <RBRACKET> { k++; } )*
		    {
		      q = new ListNode(new VarNode(t2, k));
			  p = new ListNode(new VarDeclNode(t1, q));
			}	   
	    (<COMMA> { k++; } (t1 = <PRIMITIVE_TYPE> | t1 = <IDENT>)
	    t2 = <IDENT> (<LBRACKET> <RBRACKET> { k++; } )*
			{
		  		q = new ListNode(new VarNode(t2, k));
		  		p.add(new VarDeclNode(t1, q));
			}
	    )*
	   ] { return p; }
	} catch (ParseException e) {
	   consumeUntil(g, e, "paramlist");
	   return null;
	}
}


StatementNode statement(RecoverySet g) throws ParseEOFException :
{
StatementNode s = null;
ListNode l;
Token t1 = null;

RecoverySet f1 = new RecoverySet(SEMICOLON).union(g).remove(IDENT),
			f2 = new RecoverySet(RBRACE).union(g).remove(IDENT);
}
{
	try {
	(
			LOOKAHEAD(3) s = vardecl(f1) <SEMICOLON>
		|	LOOKAHEAD(4) methodcall(f1) <SEMICOLON>
		|	LOOKAHEAD(3) s = atribstat(f1) <SEMICOLON>
		|	s = printstat(f1) <SEMICOLON>
		|	s = readstat(f1) <SEMICOLON>
		|	s = returnstat(f1) <SEMICOLON>
		|	s = superstat(f1) <SEMICOLON>
		|	s = ifstat(g)
		|	s = forstat(g)
		|	t1 = <LBRACE> l= statlist(f2) <RBRACE> { s = new BlockNode(t1, l); }
		|	t1 = <BREAK> <SEMICOLON> {  s = new BreakNode(t1); }
		|	<SEMICOLON> {  s = new NopNode(t1); }
	) { return s; }
	} catch(ParseException e) {
		consumeUntil(g, e, "statement");
		return new NopNode(t1);
	}
}


StatementNode methodcall(RecoverySet g) throws ParseEOFException:
{
  Token t1 = null, t2 = null;
  ListNode l = null;
  MethodCallNode m = null;
  
  RecoverySet f1 = new RecoverySet(RPAREN).union(g);
}
{
try { 
	 t2 = <IDENT>
	 [<DOT> { t1 = t2; } t2 = <IDENT> ]
  	 (<DOT> { t1 = t2; } t2 = <IDENT> )* <LPAREN> l = arglist(f1) <RPAREN>
		{
  			m = new MethodCallNode(t2, t1, l);
  		 	return m;
  		} 
	}
	catch(ParseException e) {
		consumeUntil(g, e, "methodcall");
		{ return m; } 
	}
}


ExpreNode lvalue(RecoverySet g) throws ParseEOFException :
{
ExpreNode e1 = null,
		  e2 = null;
Token t1 = null,
	  t2 = null;
ListNode l = null;
}
{
try { 
  t1 = <IDENT> { e1 = new VarNode(t1); }
  (
           t1 = <LBRACKET> e2 = expression(null) <RBRACKET> 
           		{ e1 = new IndexNode(t1, e1, e2); }
  |
           t1 = <DOT> t2 = <IDENT> [<LPAREN> l = arglist(null) <RPAREN>]
           {
             	if(l == null)
             		e1 = new DotNode(t1, e1, t2);
             	else
             		e1 = new CallNode(t1, e1, t2, l);
          	}
  )*
  { return e1; }
}
catch (ParseException e)
{
  consumeUntil(g, e, "lvalue");
  return new VarNode(t1);
}
}


AtribNode atribstat(RecoverySet g) throws ParseEOFException :
{
ExpreNode e1 = null,
		  e2 = null;
Token t1 = null;

RecoverySet f1 = new RecoverySet(ASSIGN).union(g);
}
{
try { 
    e1 = lvalue(f1) t1 = <ASSIGN>
    ( e2 = alocexpression(g) | e2 = expression(g))
    {return new AtribNode(t1, e1, e2); }
}
catch (ParseException e)
{
  consumeUntil(g, e, "atribstat");
  return new AtribNode(t1, e1, e2); 
}
}


PrintNode printstat(RecoverySet g) throws ParseEOFException :
{
ExpreNode e1 = null;
Token t = null;
}
{
try { 
    t = <PRINT> e1 = expression(g)
    	{ return new PrintNode(t, e1); }
}
catch (ParseException e)
{
  consumeUntil(g, e, "printstat");
  return new PrintNode(t, e1);
}
}

ReadNode readstat(RecoverySet g) throws ParseEOFException :
{
ExpreNode e1 = null;
Token t = null;
}
{
try { 
    t = <READ> e1 = lvalue(g)
    { return new ReadNode(t, e1); }
}
catch (ParseException e)
{
  consumeUntil(g, e, "readstat");
  return new ReadNode(t, e1);
}
}


ReturnNode returnstat(RecoverySet g) throws ParseEOFException :
{
ExpreNode e1 = null;
Token t = null;
}
{
try { 
    t = <RETURN> [ e1 = expression(g)]
    { return new ReturnNode(t, e1); }
}
catch (ParseException e)
{
  consumeUntil(g, e, "returnstat");
  return new ReturnNode(t, e1);
}
}


SuperNode superstat(RecoverySet g) throws ParseEOFException :
{
ListNode l = null;
Token t = null;

RecoverySet f = new RecoverySet(RPAREN).union(g);
}
{
try { 
    t = <SUPER> <LPAREN> l = arglist(f) <RPAREN>
    { return new SuperNode(t, l); }
}
catch (ParseException e)
{
  consumeUntil(g, e, "superstat");
  return new SuperNode(t, l);
}
}


IfNode ifstat(RecoverySet g) throws ParseEOFException :
{
ExpreNode e1 = null;
StatementNode s1 = null,
			  s2 = null;
Token t = null;

RecoverySet f1 = new RecoverySet(RPAREN).union(g),
			f2 = new RecoverySet(ELSE).union(g);
}
{
try { 
	t = <IF> <LPAREN> e1 = expression(f1) <RPAREN> s1 = statement(f2)
	[LOOKAHEAD(1) <ELSE> s2 = statement(g)]
	{ return new IfNode(t, e1, s1, s2); }
}
catch (ParseException e)
{
  consumeUntil(g, e, "ifstat");
  return new IfNode(t, e1, s1, s2);
}
}


ForNode forstat(RecoverySet g) throws ParseEOFException :
{
AtribNode s1 = null,
		  s2 = null;
StatementNode s3 = null;
ExpreNode e1 = null;
Token t = null;

RecoverySet f1 = new RecoverySet(SEMICOLON).union(g),
			f2 = new RecoverySet(RPAREN).union(g);
}
{
try { 
    t = <FOR> <LPAREN> [s1 = atribstat(f1)] <SEMICOLON>
                   [e1 = expression(f1)] <SEMICOLON>
                   [s2 = atribstat(f2)] <RPAREN>
                    s3 = statement(g)
        { return new ForNode(t, e1, s1, s2, s3); }
}
catch (ParseException e)
{
  consumeUntil(g, e, "forstat");
  return new ForNode(t, e1, s1, s2, s3);
}
}


ListNode statlist(RecoverySet g) throws ParseEOFException :
{
ListNode l = null;
StatementNode s = null;

RecoverySet f = First.statlist.remove(IDENT).union(g);
}
{
  s = statement(f) [l = statlist(g)]
  { return new ListNode(s, l); }
}


ExpreNode alocexpression(RecoverySet g) throws ParseEOFException :
{
ExpreNode e1 = null,
		  e2 = null;
ListNode l = null;
Token t1, t2;

RecoverySet f1 = new RecoverySet(RPAREN).union(g),
			f2 = new RecoverySet(RBRACKET).union(g);
}
{
    t1 = <NEW>
    (
     LOOKAHEAD(2) (t2 = <IDENT> <LPAREN> l = arglist(f1) <RPAREN>)
		{ e1 = new NewObjectNode(t1, t2, l); }
|
     (t2 = <PRIMITIVE_TYPE> | t2 = <IDENT>)
     (<LBRACKET> e2 = numexpr(f2) <RBRACKET>
           {
           	  if ( l == null )
     		  l = new ListNode(e2);
           	  else
           	  	l.add(e2);
           	}
          )+
          	{ e1 = new NewArrayNode(t1, t2, l); }
    )
    { return e1; }
}


ExpreNode expression(RecoverySet g) throws ParseEOFException :
{
boolean eq = false;
Token t = null, t1 = null, t2 = null;
ExpreNode e = null, e1 = null, e2 = null, e3 = null;
}
{
try { 
	[t = <NOT>] e1 = numexpr(g)
	[((t1 = <LT> | t1 = <GT> | t1 = <LE> | t1 = <GE>) | (t1 = <EQ> { eq = true; } | t1 = <NEQ> { eq = true; } )) e2 = numexpr(g)]
	[(t2 = <AND>|t2 = <OR>|t2 = <XOR>) e3 = expression(g)]
	{
			if(t == null && t1 == null && t2 == null) { 
					e = e1;
			} else {
			  		e = new BooleanExpressionNode(t, e1, t1, eq, e2, t2, e3);
			}
			return e;
	}
}
catch (ParseException ex)
{
  consumeUntil(g, ex, "expression");
  return e;
}
}


ExpreNode numexpr(RecoverySet g) throws ParseEOFException :
{
ExpreNode e1 = null, e2;
Token t;
}
{
  try { 
    e1 = term()
    (
      (t = <PLUS> | t = <MINUS>)
      e2 = term()
		{ e1 = new AddNode(t, e1, e2); }
    )*
    { return e1; }
  }
  catch(ParseException e)
  {
    consumeUntil(g, e, "numexpr");
    { return e1; }
  }
}


ExpreNode term() throws ParseEOFException :
{
ExpreNode e1 = null, e2;
Token t;
}
{
	e1 = unaryexpr()
	(
	  (t = <MULTIPLY> | t = <DIVIDE> | t = <REM>)
	  e2 = unaryexpr()
		{ e1 = new MultNode(t, e1, e2); }
	)*
	{ return e1; }
}


ExpreNode unaryexpr() throws ParseEOFException :
{
ExpreNode e;
Token t = null;
}
{
   [(t = <PLUS> | t = <MINUS>)] e = factor()
   {  return ((t == null) ? e : new UnaryNode(t, e)); }
}


ExpreNode factor() throws ParseEOFException :
{
ExpreNode e = null;
Token t = null;
}
{
    (
       t = <number_constant> { e = new IntConstNode(t); }
       |
       t = <string_constant> { e = new StringConstNode(t); }
       |
       t = < char_const > { e = new CharConstNode(t); }
       |  
       t = <null_constant> { e = new NullConstNode(t); }
       |
       t = <boolean_constant> { e = new BooleanConstNode(t); }
       |
       e = lvalue(null)
       |
       <LPAREN> expression(null) <RPAREN>
	)
	{ return e; }
}


ListNode arglist(RecoverySet g) throws ParseEOFException :
{
ListNode l = null;
ExpreNode e = null;

RecoverySet f = new RecoverySet(COMMA).union(g);
}
{
    [
    	e = expression(f)
			{ l = new ListNode(e); }
    	(<COMMA> e = expression(f)
			{ l.add(e); }
    	)*
    ]
    { return l; }
}