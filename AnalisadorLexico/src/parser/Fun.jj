/**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */
options
{
  static = false;
}

PARSER_BEGIN(Fun)
package parser;

PARSER_BEGIN(Fun)
package parser;

public class Fun
{
  public static void main(String args []) throws ParseException
  {
    Fun parser = new Fun(System.in);

	try { 
    	parser.program();
    	System.out.println("Sucesso!");
  	} catch (ParseException e) {
  		System.out.println(e);
  	} catch (TokenMgrError e) {
  	  	System.out.println(e);
  	}
  }
} // Fun

PARSER_END(Fun)

TOKEN_MGR_DECLS :
{
	int countLexError = 0;

	public int foundLexError()
	{
	  return countLexError;
	}
}

SKIP:
{
  "/*" : multilinecomment
| 
  "//" : singlelinecomment
}

<singlelinecomment> SKIP:
{
  <["\n","\r"]> : DEFAULT
| <~[]>
}

<multilinecomment> SKIP:
{
  "*/" : DEFAULT
| <~[]>
}

SKIP:
{
 " "
| "\r"
| "\t"
| "\n"
}

/* Palavras Reservadas da Linguagem */
TOKEN:
{
  < BREAK: "break" >
| < CLASS: "class" >
| < CONSTRUCTOR: "constructor" >
| < ELSE: "else" >
| < EXTENDS: "extends" >
| < FOR: "for" >
| < IF: "if" >
| < NEW: "new" >
| < PRINT: "print" >
| < READ: "read" >
| < RETURN: "return" >
| < SUPER: "super" >
}

/* Tipos de Variáveis da Linguagem */
TOKEN:
{
  < INT: "int" >
| < STRING: "string >
| < CHAR: "char" >
| < DOUBLE: "double" >
| < FLOAT: "float >
}

/* Qualificadores da Linguagem */
TOKEN:
{
  < PUBLIC: "public" >
| < PROTECTED: "protected" >
| < PRIVATE: "private" >
| < FINAL: "final" >
}

/* Operadores da Linguagem */
TOKEN:
{
  < ASSIGN: "=" >
| < GT: ">" >
| < LT: "<" >
| < EQ: "==" >
| < LE: "<=" >
| < GE: ">=" >
| < NEQ: "!=" >
| < PLUS: "+" >
| < MINUS: "-" >
| < MULTIPLY: "*" >
| < DIVIDE: "/" >
| < REM: "%" >
}

/* Operadores Lógicos */
TOKEN:
{
| < XOR: "xor" >
| < NOT: "not" >
| < AND: "and" >
| < OR: "or" >
}

/* Simbolos Especiais da Linguagem */
TOKEN:
{
  < LPAREN: "(" >
| < RPAREN: ")" >
| < LBRACE: "{" >
| < RBRACE: "}" >
| < LBRACKET: "[" >
| < RBRACKET: "]" >
| < SEMICOLON: ";" >
| < COMMA: "," >
| < DOT: "." >
}

/* Constantes da Linguagem */
TOKEN:
{
  < int_constant:( //números decimais,octais, hexadeciamais ou binários
    			  (["0"-"9"] (["0"-"9"])*) |
    			  (["0"-"7"] (["0"-"7"])* (["o", "0"]) |
    			  (["0"-"9"] (["0"-"7","A"-"F","a"-"f"])* ["h", "H"] ) |
    			  (["0"-"1"] (["0"-"1"])* ["b", "B"])
    			  ))> 
| 
  <  string_constant: //"constante string como "abcd"
  		"\""( ~["\"","\n","\r"])* "\"" >
|
  < null_constant : "null" > // constant null
|
  < int_literal : < DIGIT >(< DIGIT >)* >
|
  < float_literal:	(< int_literal >) "." ( < int_literal > (( "e" | "E" ) ("-")?
  < int_literal > )?)? |
  						(< int_literal >)? "." (< int_literal > (( "e" | "E" ) ("-")?
  						< int_literal > )? ) >
|
	< CHARACTER:(   (~["'"," ","\\","\n","\r"])
			|	("\\"
    				( ["n","t","b","r","f","\\","'","\""]
    		| 		  ["u","U"]["+"]["0"-"9","a"-"f","A"-"F"]["0"-"9","a"-"f","A"-"F"]["0"-"9","a"-"f","A"-"F"]["0"-"9","a"-"f","A"-"F"]
    				)
  				) )>
}

/* Identificadores da Linguagem */
TOKEN:
{
  < IDENT: <LETTER> (<LETTER>|<DIGIT>)* >
|
  < #LETTER:["A"-"Z","a"-"z"] >
|
  < #DIGIT:["0"-"9"] >
}

SPECIAL_TOKEN:
{
<INVALID_LEXICAL:
(~ ["a"-"z", "A"-"Z",
	"0"-"9",
	"\"",
	"(",
	")",
	"[",
	"]",
	"{",
	"}",
	";",
	",",
	".",
	"=",
	">",
	"<",
	"!",
	"+",
	"-",
	"*",
	"/",
	"%",
	" ",
	"\t",
	"\n",
	"\r",
	"\f"
])+ >
	{
	  System.err.println("Line " + input_stream.getEndLine() +
	  					 " - Invalid string found: " + image);
	  countLexError++;
	}
|
	< INVALID_CONSTANT:
	"\"" (~ ["\n","\r","\""])* ["\n","\r"]>
	{
	  System.err.println("Line " + input_stream.getEndLine() +
	  					 " - String constant has a \\n: " + image);
	  countLexError++;
	}
}

int one_line() :
{}
{
  sum() ";"
  {
    return 0;
  }
| ";"
  {
    return 1;
  }
}

void sum() :
{}
{
  term()
  (
    (
      < PLUS >
    | < MINUS >
    )
    term()
  )*
}

void term() :
{}
{
  unary()
  (
    (
      < MULTIPLY >
    | < DIVIDE >
    )
    unary()
  )*
}

void unary() :
{}
{
  < MINUS > element()
| element()
}

void element() :
{}
{
  < CONSTANT >
| "(" sum() ")"
}
