/**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */
options
{
  STATIC = false;
  DEBUG_LOOKAHEAD = true;
}

PARSER_BEGIN(Fun)
package parser;
import java.io.FileInputStream;

public class Fun
{
final static String Version = "F++ Compiler - Version 1.1 - 2018";
int contParseError = 0;

// Define método "main" da classe Fun
	public static void main(String args[])
	{
	boolean debug = false;

		String filename = "";
		fun parser;
		int i;
		boolean ms = false;

		System.out.println(Version);
		// lê os parâmetros passados para o compilador
		for (i = 0; i < args.length -1; i++)
		{
		  if(args[i].equals("-debug_AS") )
		  		debug = true;
		  else
		  	{
		  	  	System.out.println("Utilizacao : " +
		  	  						"java fun [-debug_AS] inputfile");
		  	  	System.exit(0);
		 	}
		}

		if (args[i].equals("-"))
		{ //lê da entrada padrão
			System.out.println("Lendo da entrada padrão ...");
			parser = new fun(System.in); // cria AS
		}
		else
		{ // lê do arquivo
			filename = args[args.length-1];
			System.out.println("Lendo arquivo " + filename + " ...");
			try {
				parser = new fun(new java.io.FileInputStream(filename));
			}
		  catch (java.io.FileNotFoundExcpetion e) {
		    		System.out.println("Arquivo " + filename + " nao encontrado.");
		    		return;
		 			}
		}

		if (!debug) parser.disable_tracing(); // desabilita verbose do AS

		try {
		  		parser.program(); //chama o método para fazer análise
		}
		catch (ParseExcpetion e)  	
		{
		System.err.println(e.getMessage());
		parser.contParseError = 1; // não existe recuperação de erros
		}
		finally {
		  System.out.println(parser.token_source.foundLexError() +
		  						"Lexical Errors found");
		  System.out.println(parser.contParseError +
		  						"Syntatic Errors found");
		  	}
	} //main


static public String im(int x)
{
  int k;
  String s;
  	s = tokenImage[x];
  	k = s.lastIndexOf("\"");
  	try {s = s.substring(1,k); }
  	catch (StringIndexOutOfBoundsException e)
  	{}
  	return s;
}

} // Fun

PARSER_END(Fun)

TOKEN_MGR_DECLS :
{
	int countLexError = 0;

	public int foundLexError()
	{
	  return countLexError;
	}
}

SKIP:
{
  "/*" : multilinecomment
| 
  "//" : singlelinecomment
}

<singlelinecomment> SKIP:
{
  <["\n","\r"]> : DEFAULT
| <~[]>
}

<multilinecomment> SKIP:
{
  "*/" : DEFAULT
| <~[]>
}

SKIP:
{
 " "
| "\r"
| "\t"
| "\n"
}

/* Palavras Reservadas da Linguagem */
TOKEN:
{
  < BREAK: "break" >
| < CLASS: "class" >
| < CONSTRUCTOR: "constructor" >
| < ELSE: "else" >
| < EXTENDS: "extends" >
| < FOR: "for" >
| < IF: "if" >
| < NEW: "new" >
| < PRINT: "print" >
| < READ: "read" >
| < RETURN: "return" >
| < SUPER: "super" >
}

/* Tipos de Variáveis da Linguagem */
TOKEN:
{
  < INT: "int" >
| < STRING: "string" >
| < CHAR: "char" >
| < DOUBLE: "double" >
| < FLOAT: "float" >
}

/* Qualificadores da Linguagem */
TOKEN:
{
  < PUBLIC: "public" >
| < PROTECTED: "protected" >
| < PRIVATE: "private" >
| < FINAL: "final" >
}

/* Operadores da Linguagem */
TOKEN:
{
  < ASSIGN: "=" >
| < GT: ">" >
| < LT: "<" >
| < EQ: "==" >
| < LE: "<=" >
| < GE: ">=" >
| < NEQ: "!=" >
| < PLUS: "+" >
| < MINUS: "-" >
| < MULTIPLY: "*" >
| < DIVIDE: "/" >
| < REM: "%" >
| < BOOLEAN: "true"|"false" >
}

/* Operadores Lógicos */
TOKEN:
{
  < XOR: "xor" >
| < NOT: "not" >
| < AND: "and" >
| < OR: "or" >
}

/* Simbolos Especiais da Linguagem */
TOKEN:
{
  < LPAREN: "(" >
| < RPAREN: ")" >
| < LBRACE: "{" >
| < RBRACE: "}" >
| < LBRACKET: "[" >
| < RBRACKET: "]" >
| < SEMICOLON: ";" >
| < COMMA: "," >
| < DOT: "." >
| < SINGLE_QUOTATION_MARKS: "'" >
}

/* Constantes da Linguagem */
TOKEN:
{
  < int_constant:( //números decimais,octais, hexadeciamais ou binários
    			  (["0"-"9"] (["0"-"9"])*) |
    			  (["0"-"7"] (["0"-"7"])* (["o", "0"]) |
    			  (["0"-"9"] (["0"-"7","A"-"F","a"-"f"])* ["h", "H"] ) |
    			  (["0"-"1"] (["0"-"1"])* ["b", "B"])
    			  ))> 
| 
  <  string_constant: //"constante string como "abcd"
  		"\""( ~["\"","\n","\r"])* "\"" >

|
  < null_constant : "null" > // constant null
|
  < int_literal : < DIGIT >(< DIGIT >)* >
|

//  Float que aceita notação ciêntifica
//  < float_literal:	(< int_literal >) "." ( < int_literal > (( "e" | "E" ) ("-")?
//  < int_literal > )?)? |
//  						(< int_literal >)? "." (< int_literal > (( "e" | "E" ) ("-")?
//  						< int_literal > )? >

	< float_literal:	( < int_literal > ) "." ( < int_literal > ) >
|
//	< CHARACTER:( (~[" ","\\","\n","\r"])
//			|	("\\"
//    				( ["n","t","b","r","f","\\","'","\""]
//    		| 		  ["u","U"]["+"]["0"-"9","a"-"f","A"-"F"]["0"-"9","a"-"f","A"-"F"]["0"-"9","a"-"f","A"-"F"]["0"-"9","a"-"f","A"-"F"]
//    				) 
//  				) )>

	< CHARACTER: ( (["\'"])(["A"-"Z","a"-"z","0"-"9"])(["\'"]) ) >
|
	< #EXPONENT: ["e","E"] (["+","-"])?  (["0"-"9"])+ >
}

/* Identificadores da Linguagem */
TOKEN:
{
  < CONSTANT : (< DIGIT >)+ >
| 
  < IDENT: <LETTER> (<LETTER>|<DIGIT>)* >
|
  < #LETTER:["A"-"Z","a"-"z"] >
|
  < #DIGIT:["0"-"9"] >
}

/* Tipos primitivos da Linguagem */
TOKEN:
{
  < primitivetype: "int"|"char"|"boolean"|"float"|"not"|"and"|"or"|"xor" >
}

SPECIAL_TOKEN:
{
<INVALID_LEXICAL:
(~ ["a"-"z", "A"-"Z",
	"0"-"9",
	"\"",
	"(",
	")",
	"[",
	"]",
	"{",
	"}",
	";",
	",",
	".",
	"=",
	">",
	"<",
	"!",
	"+",
	"-",
	"*",
	"/",
	"%",
	" ",
	"\t",
	"\n",
	"\r",
	"\f"
])+ >
	{
	  System.err.println("Line " + input_stream.getEndLine() +
	  					 " - Invalid string found: " + image);
	  countLexError++;
	}
|
	< INVALID_CONSTANT:
	"\"" (~ ["\n","\r","\""])* ["\n","\r"]>
	{
	  System.err.println("Line " + input_stream.getEndLine() +
	  					 " - String constant has a \\n: " + image);
	  countLexError++;
	}
}

void program() :
{
}
{
  [ classlist() ] <EOF>
}

void classlist():
{
}
{
  classdecl() [classlist()]
}


void classdecl():
{
}
{
	<CLASS>	<IDENT> [ <EXTENDS> <IDENT> ] classbody()
}

void vardecl() :
{
}
{
	(<INT> | <STRING> | <IDENT>)
	<IDENT> (<LBRACKET> <RBRACKET>)*
	(<COMMA> <IDENT> ( <RBRACKET> <LBRACKET>)* )*
}

void constructdecl():
{
}
{
	<CONSTRUCTOR> methodbody()
}

void methoddecl():
{
}
{
	(<INT> | <STRING> | <IDENT> ) (<RBRACKET> <LBRACKET>)*
	<IDENT> methodbody()
}

void classbody():
{
}
{
	<LBRACE>
		[classlist()]
		(LOOKAHEAD(3) vardecl() <SEMICOLON>)*
		(constructdecl())*
		(methoddecl())*
	<RBRACE>
}

void methodbody():
{
}
{
  < LPAREN > paramlist() < RPAREN > statement()
}

void paramlist():
{
}
{
  [
  	( < INT > | < STRING > | < IDENT >) < IDENT > (< RBRACKET > <LBRACKET >)*
  	( < COMMA > (< INT > | < STRING > | < IDENT >)
  			< IDENT > (< RBRACKET > <LBRACKET >)*
 	)*
  ]
}

void statement():
{
}
{
	LOOKAHEAD(2)
	vardecl()
|
	atribstat() <SEMICOLON>
|
	printstat() <SEMICOLON>
|
	readstat() <SEMICOLON>
| 
	returnstat() <SEMICOLON>
|
	superstat() <SEMICOLON>
|
	ifstat()
|
	forstat()
|
	<LBRACE> statlist() <RBRACE>
|
	<BREAK> <SEMICOLON>
|
	<SEMICOLON>
}

void atribstat():
{
}
{
  	lvalue() <ASSIGN> ( alocexpression() | expression())
}

void printstat():
{
}
{
	<PRINT> expression()
}

void readstat():
{
}
{
	<READ> lvalue()
}

void returnstat():
{
}
{
	<RETURN> [expression()]
}

void superstat():
{
}
{
	<SUPER> <LPAREN> arglist() <RPAREN>
}

void ifstat():
{
}
{
	<IF> <LPAREN> expression() <RPAREN> statement()
	[LOOKAHEAD(1) <ELSE> statement()]
}

void forstat():
{
}
{
	<FOR> <LPAREN>  [atribstat()] <SEMICOLON>
					[expression()] <SEMICOLON>
					[atribstat()] <RPAREN>
						statement()
}

void statlist():
{
}
{
	statement() [statlist()]
}

void lvalue():
{
}
{
	<IDENT> (
				<LBRACKET> expression() <RBRACKET> |
				<DOT> <IDENT> [<LPAREN> arglist() <RPAREN>]
			)*
}

void alocexpression():
{
}
{
	<NEW> (
			LOOKAHEAD(2) <IDENT> <LPAREN> arglist() <RPAREN> |
			( <INT> | <STRING> | <IDENT> )
			(<LBRACKET> expression() <RBRACKET>)+
		   )
}

voi expression():
{
}
{
	numexpr() [( <LT> | <GT> | <LE> | <GE> | <EQ> | <NEQ>) numexpr()]
}

void numexpr():
{
}
{
	term() ((<PLUS> | <MINUS>) term())*
}

void term():
{
}
{
	unaryexpr() ((<MULTIPLY> | <DIVIDE> | <REM>) unaryexpr())*
}

void unaryexpr():
{
}
{
	[(<PLUS> | <MINUS>)] factor()
}

void factor():
{
}
{

	(
		<int_constant> |
		<string_constant> |
		<null_constant> |
		lvalue() | 
		<LPAREN> expression() <RPAREN>)
}

void arglist():
{
}
{
	[expression() (<COMMA> expression())*]
}

