/**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */
options
{
  static = false;
}

PARSER_BEGIN(Fun)
package parser;
import java.io.FileInputStream;

public class Fun
{
boolean Menosshort = false;

  public static void main(String args []) throws ParseException
  {
    String filename = ""; // nome do arquivo a ser analisado;
    Fun parser;
    int i = 0;
    boolean minusshort = false;
    
    // Lê os parametros passados ao compilador
    while( i < args.length -1) {
    	if(args[i].toLowerCase().equals("-short")) {
    		minusshort = true;
    	} else {
    		System.out.println("Usage is: java Fun [-short] inputfile");
    		System.exit(0);
    	}
    }
    
    if (args[i].equals("-")) {
    	// Lê Stdin
    	System.out.println("Lendo da entrada padrao");
    	parser = new Fun(System.in);
    }
    else
    {
    	// Lê do arquivo passado
    	filename = args[args.length-1];
    	System.out.println("Lendo do arquivo " + filename +"");
    	try {
    		parser = new Fun(new FileInputStream(filename));
    	}
    	catch (java.io.FileNotFoundException e) {
    		System.out.println("Arquivo" + filename + " nao encontrado");
    		return;
    	}
    }
    parser.Menosshort = minusshort;
    parser.program();
    if(parser.token_source.foundLexError() != 0 ) // verifica erros lexicos
    	System.out.println(parser.token_source.foundLexError() + 
    			"Erros lexicos encontrados");
    	else
    		System.out.println("Programa analizado");
}

  static public String image(int x) {
	int k;
	String s;
		s = tokenImage[x];
		k = s.lastIndexOf("\u005c"");
		try {
			s = s.substring(1, k);
		} catch (StringIndexOutOfBoundsException e) {}
	  return s;
	}

} // Fun

PARSER_END(Fun)

TOKEN_MGR_DECLS :
{
	int countLexError = 0;

	public int foundLexError()
	{
	  return countLexError;
	}
}

SKIP:
{
  "/*" : multilinecomment
| 
  "//" : singlelinecomment
}

<singlelinecomment> SKIP:
{
  <["\n","\r"]> : DEFAULT
| <~[]>
}

<multilinecomment> SKIP:
{
  "*/" : DEFAULT
| <~[]>
}

SKIP:
{
 " "
| "\r"
| "\t"
| "\n"
}

/* Palavras Reservadas da Linguagem */
TOKEN:
{
  < BREAK: "break" >
| < CLASS: "class" >
| < CONSTRUCTOR: "constructor" >
| < ELSE: "else" >
| < EXTENDS: "extends" >
| < FOR: "for" >
| < IF: "if" >
| < NEW: "new" >
| < PRINT: "print" >
| < READ: "read" >
| < RETURN: "return" >
| < SUPER: "super" >
}

/* Tipos de Variáveis da Linguagem */
TOKEN:
{
  < INT: "int" >
| < STRING: "string" >
| < CHAR: "char" >
| < DOUBLE: "double" >
| < FLOAT: "float" >
}

/* Qualificadores da Linguagem */
TOKEN:
{
  < PUBLIC: "public" >
| < PROTECTED: "protected" >
| < PRIVATE: "private" >
| < FINAL: "final" >
}

/* Operadores da Linguagem */
TOKEN:
{
  < ASSIGN: "=" >
| < GT: ">" >
| < LT: "<" >
| < EQ: "==" >
| < LE: "<=" >
| < GE: ">=" >
| < NEQ: "!=" >
| < PLUS: "+" >
| < MINUS: "-" >
| < MULTIPLY: "*" >
| < DIVIDE: "/" >
| < REM: "%" >
| < BOOLEAN: "true"|"false" >
}

/* Operadores Lógicos */
TOKEN:
{
  < XOR: "xor" >
| < NOT: "not" >
| < AND: "and" >
| < OR: "or" >
}

/* Simbolos Especiais da Linguagem */
TOKEN:
{
  < LPAREN: "(" >
| < RPAREN: ")" >
| < LBRACE: "{" >
| < RBRACE: "}" >
| < LBRACKET: "[" >
| < RBRACKET: "]" >
| < SEMICOLON: ";" >
| < COMMA: "," >
| < DOT: "." >
| < SINGLE_QUOTATION_MARKS: "'" >
}

/* Constantes da Linguagem */
TOKEN:
{
  < int_constant:( //números decimais,octais, hexadeciamais ou binários
    			  (["0"-"9"] (["0"-"9"])*) |
    			  (["0"-"7"] (["0"-"7"])* (["o", "0"]) |
    			  (["0"-"9"] (["0"-"7","A"-"F","a"-"f"])* ["h", "H"] ) |
    			  (["0"-"1"] (["0"-"1"])* ["b", "B"])
    			  ))> 
| 
  <  string_constant: //"constante string como "abcd"
  		"\""( ~["\"","\n","\r"])* "\"" >

|
  < null_constant : "null" > // constant null
|
  < int_literal : < DIGIT >(< DIGIT >)* >
|

//  Float que aceita notação ciêntifica
//  < float_literal:	(< int_literal >) "." ( < int_literal > (( "e" | "E" ) ("-")?
//  < int_literal > )?)? |
//  						(< int_literal >)? "." (< int_literal > (( "e" | "E" ) ("-")?
//  						< int_literal > )? >

	< float_literal:	( < int_literal > ) "." ( < int_literal > ) >
|
//	< CHARACTER:( (~[" ","\\","\n","\r"])
//			|	("\\"
//    				( ["n","t","b","r","f","\\","'","\""]
//    		| 		  ["u","U"]["+"]["0"-"9","a"-"f","A"-"F"]["0"-"9","a"-"f","A"-"F"]["0"-"9","a"-"f","A"-"F"]["0"-"9","a"-"f","A"-"F"]
//    				) 
//  				) )>

	< CHARACTER: (["\'"])(["A"-"Z","a"-"z","0"-"9"])(["\'"]) ) >
|
	< #EXPONENT: ["e","E"] (["+","-"])?  (["0"-"9"])+ >
}

/* Identificadores da Linguagem */
TOKEN:
{
  < CONSTANT : (< DIGIT >)+ >
| 
  < IDENT: <LETTER> (<LETTER>|<DIGIT>)* >
|
  < #LETTER:["A"-"Z","a"-"z"] >
|
  < #DIGIT:["0"-"9"] >
}

/* Tipos primitivos da Linguagem */
TOKEN:
{
  < primitivetype: "int"|"char"|"boolean"|"float"|"not"|"and"|"or"|"xor" >
}

SPECIAL_TOKEN:
{
<INVALID_LEXICAL:
(~ ["a"-"z", "A"-"Z",
	"0"-"9",
	"\"",
	"(",
	")",
	"[",
	"]",
	"{",
	"}",
	";",
	",",
	".",
	"=",
	">",
	"<",
	"!",
	"+",
	"-",
	"*",
	"/",
	"%",
	" ",
	"\t",
	"\n",
	"\r",
	"\f"
])+ >
	{
	  System.err.println("Line " + input_stream.getEndLine() +
	  					 " - Invalid string found: " + image);
	  countLexError++;
	}
|
	< INVALID_CONSTANT:
	"\"" (~ ["\n","\r","\""])* ["\n","\r"]>
	{
	  System.err.println("Line " + input_stream.getEndLine() +
	  					 " - String constant has a \\n: " + image);
	  countLexError++;
	}
}

int one_line() :
{}
{
  sum() ";"
  {
    return 0;
  }
| ";"
  {
    return 1;
  }
}

void sum() :
{}
{
  term()
  (
    (
      < PLUS >
    | < MINUS >
    )
    term()
  )*
}

void term() :
{}
{
  unary()
  (
    (
      < MULTIPLY >
    | < DIVIDE >
    )
    unary()
  )*
}

void unary() :
{}
{
  < MINUS > element()
| element()
}

void element() :
{}
{
  < CONSTANT >
| "(" sum() ")"
}


JAVACODE void program()
{
Token t;
    do
    {
    t = getNextToken();
    Token st = t;
        while ( st.specialToken != null)
        st = st.specialToken;
        do {
           if ( Menosshort )
          System.out.println(st.image + "  " + 
                                 image(st.kind) + " " +
                                 st.kind);
           else
              System.out.println("Line: " + st.beginLine + 
                                 " Column: " + st.beginColumn + 
                                 " " + st.image +
                                 "  " + image(st.kind) + "  "+t.kind);
          st = st.next;       
        } while (st != t.next);
    } while (t.kind != FunConstants.EOF);  
}
